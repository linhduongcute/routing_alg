####################################################
# DVrouter.py
# Name:
# HUID:
#####################################################

import math
import base64
import pickle

from router import Router
from typing import Any, Optional
from packet import Packet

INFINITY = math.inf
_Cost = int
_Addr = Any
_Port = Any

class ForwardingTableEntry:
    def __init__(self, cost: _Cost, next_hop: Optional[_Addr], port: Optional[_Port]):
        self.cost = cost
        self.optional_next_hop = next_hop
        self.optional_port = port

class NeighborEntry:
    def __init__(self, cost: _Cost, port : _Port):
        self.cost = cost
        self.port = port

class DistanceVectorEntry:
    def __init__(self, cost: _Cost, next_hop: _Addr):
        self.cost = cost
        self.next_hop = next_hop

def serialize(obj: Any) -> str:
    return base64.b64encode(pickle.dumps(obj)).decode()
def deserialize(str_: str) -> Any:
    return pickle.loads(base64.b64decode(str_.encode()))

class DVrouter(Router):
    """Distance vector routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """
    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.forwarding_table : dict[_Addr, ForwardingTableEntry] = {} # destination - entry
        self.forwarding_table[self.addr] = ForwardingTableEntry(cost = 0, next_hop = self.addr, port = None)
        self.neighbor_data_by_addr : dict[_Addr, NeighborEntry] = {} #addr - entry, each neighbor hop = neighbor cost
        self.neighbor_addr_by_port : dict[_Port, _Addr] = {} #port-address
        pass

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dst_addr in self.forwarding_table:
                dst_cost_and_port = self.forwarding_table[packet.dst_addr]
                if dst_cost_and_port.cost < INFINITY and dst_cost_and_port.optional_port is not None:
                    self.send(dst_cost_and_port.optional_port, packet)
            pass
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the received distance vector is different
            #   update the local copy of the distance vector
            #   update the distance vector of this router
            #   update the forwarding table
            #   broadcast the distance vector of this router to neighbors
            distance_vector: dict[_Addr, DistanceVectorEntry] = deserialize(packet.content)
            neighbor_addr = packet.src_addr
            is_forwarding_table_changed = False

            # handle neighbor route Infinity -> current route to that dest also inf
            for dest, dest_data in distance_vector.items():
                if dest_data.cost == INFINITY:
                    if dest in self.forwarding_table and self.forwarding_table[dest].optional_next_hop == neighbor_addr:
                        self.forwarding_table[dest] = ForwardingTableEntry(cost= INFINITY, next_hop= None, port= None)
                        is_forwarding_table_changed = True

            # change forwarding table of current router when new cost of new route in distance vector + neighbor cost <
            # change forwarding table of current router when new route to new dest availabel
                else:
                    neighbor_data = self.neighbor_data_by_addr[neighbor_addr]
                    new_cost = min(neighbor_data.cost + dest_data.cost, INFINITY)
                    neighbor_port = neighbor_data.port

                    if dest not in self.forwarding_table or self.forwarding_table[dest].cost > new_cost:
                        self.forwarding_table[dest] = ForwardingTableEntry(cost = new_cost, next_hop = neighbor_addr, port = neighbor_port)
                        is_forwarding_table_changed = True

            if is_forwarding_table_changed:
                self.broadcast_to_neighbors()
            pass

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        # update neighbor tables
        self.neighbor_addr_by_port[port] = endpoint
        self.neighbor_data_by_addr[endpoint] = NeighborEntry(cost = cost, port = port)
        optional_dest = self.forwarding_table.get(endpoint)

        # update forwarding table for new route
        if optional_dest is None or optional_dest.cost != cost:
            self.forwarding_table[endpoint] = ForwardingTableEntry(cost = cost, next_hop= endpoint, port = port)
            self.broadcast_to_neighbors()
        pass

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        neighbor_addr = self.neighbor_addr_by_port.pop(port)
        del self.neighbor_data_by_addr[neighbor_addr]

        for dest, dest_data in self.forwarding_table.items():
            if dest_data.optional_port == port:
                self.forwarding_table[dest] = ForwardingTableEntry(cost=INFINITY, next_hop=None, port=None)

        self.broadcast_to_neighbors()
        pass

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the distance vector of this router to neighbors
            self.broadcast_to_neighbors()
            pass

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"DVrouter(addr={self.addr})"

    def broadcast_to_neighbors(self):
        for neighbor_addr, neighbor_data in self.neighbor_data_by_addr.items():
            distance_vector ={}
            for dest, dest_data in self.forwarding_table.items():
                cost_broadcast = dest_data.cost
                if dest != neighbor_addr and dest_data.optional_next_hop == neighbor_addr:
                    cost_broadcast = INFINITY
                distance_vector[dest] = DistanceVectorEntry(cost = cost_broadcast, next_hop=dest_data.optional_next_hop)

            content = serialize(distance_vector)
            port = neighbor_data.port
            packet = Packet(kind=Packet.ROUTING, src_addr=self.addr, dst_addr=neighbor_addr, content=content)
            self.send(port, packet)

